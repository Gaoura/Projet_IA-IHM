#include "CircuitGraphe.h"

/*
/////////////////////////////////////////////////////////////////////////////////////////////

                ########  ########  #### ##     ##    ###    ######## ########
                ##     ## ##     ##  ##  ##     ##   ## ##      ##    ##
                ##     ## ##     ##  ##  ##     ##  ##   ##     ##    ##
                ########  ########   ##  ##     ## ##     ##    ##    ######
                ##        ##   ##    ##   ##   ##  #########    ##    ##
                ##        ##    ##   ##    ## ##   ##     ##    ##    ##
                ##        ##     ## ####    ###    ##     ##    ##    ########

/////////////////////////////////////////////////////////////////////////////////////////////
*/

Sommet<InfoSommetCarte> * CircuitGraphe::sommetAleatoire() const
{
    /* http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution */
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    int t = PElement<Sommet<InfoSommetCarte> >::taille(circuit_);
    std::uniform_int_distribution<> distr(0, t-1); // define the range
    // Use distr to transform the random unsigned int generated by gen into an int in [0., t-1]
    double n = distr(gen);

    PElement<Sommet<InfoSommetCarte> > * temp = circuit_;

    for (int i{0}; i < n; ++n)
        temp = temp->s;

    return temp->v;
}

Sommet<InfoSommetCarte> * CircuitGraphe::sommetSuivant(const Sommet<InfoSommetCarte> * s) const
{
    PElement<Sommet<InfoSommetCarte> > * temp = circuit_;

    while (temp->s != nullptr)
        if (temp->v == s)
            return temp->s->v;

    if (temp->v == s)
        return circuit_->v;

    return nullptr;
}

/*static*/ void CircuitGraphe::nouvListeCircuitGraphe(Sommet<InfoSommetCarte> * s_preums,
                                                    Sommet<InfoSommetCarte> * s_deuz,
                                                    CircuitGraphe & cg,
                                                    Sommet<InfoSommetCarte> * tab_sommets[],
                                                    const int size)
{
    int i;
    // on doit ajouter tous les sommets jusque s_preums inclu
    for (i = 0; i < size; ++i)
    {
        cg.add(tab_sommets[i]);
        if (tab_sommets[i] == s_preums)
            break;
    }

    // on garde la position du suivant de s_preums dans i
    int j = ++i;
    // et on part de j pour trouver s_deuz
    while (tab_sommets[++j] != s_deuz && j < size);
    // on garde la position du suivant de s_deuz dans j
    int k = j++;

    // tant que l'on arrive pas a l'ancien suivant de s_preums
    // on avance a reculons dans le tableau et on ajoute les sommets dans la nouvelle liste
    while(k >= i)
        cg.add(tab_sommets[k--]);

    // maintenant il ne reste plus qu'a ajouter les sommets a partir du suivant de s_deuz
    while (j < size)
        cg.add(tab_sommets[j++]);
}

/*
/////////////////////////////////////////////////////////////////////////////////////////////

                    ########  ##     ## ########  ##       ####  ######
                    ##     ## ##     ## ##     ## ##        ##  ##    ##
                    ##     ## ##     ## ##     ## ##        ##  ##
                    ########  ##     ## ########  ##        ##  ##
                    ##        ##     ## ##     ## ##        ##  ##
                    ##        ##     ## ##     ## ##        ##  ##    ##
                    ##         #######  ########  ######## ####  ######

/////////////////////////////////////////////////////////////////////////////////////////////
*/

CircuitGraphe::CircuitGraphe(Graphe<InfoAreteCarte, InfoSommetCarte> * graphe)
                            : graphe_(graphe), circuit_(nullptr)
{
    if (PElement<Sommet<InfoSommetCarte> >::taille(graphe->lSommets) < 4)
        throw Erreur("Pas de graphe de moins de 4 sommets");

}

CircuitGraphe::~CircuitGraphe()
{
    PElement<Sommet<InfoSommetCarte> >::efface1(circuit_);
}


void CircuitGraphe::add(Sommet<InfoSommetCarte> * s)
{
    // verification du parametre ------------------------------------------------------------
    if (s == nullptr)
        throw Erreur("Impossible d'ajouter un sommet NULL");

    PElement<Sommet<InfoSommetCarte> > * temp = graphe_->lSommets;
    bool trouve = false;
    while (temp != nullptr)
    {
        if (s == temp->v)
        {
            trouve = true;
            break;
        }
        temp = temp->s;
    }

    if (trouve == false)
        throw Erreur("Sommet absent du graphe");

    trouve = false;
    temp = circuit_;
    while (temp != nullptr)
    {
        if (s == temp->v)
        {
            trouve = true;
            break;
        }
        temp = temp->s;
    }

    if (trouve == true)
        throw Erreur("Sommet deja present dans la liste");

    //---------------------------------------------------------------------------------------

    // ajout du parametre en fin de liste de sommets
    PElement<Sommet<InfoSommetCarte> > * nouv_element = new PElement<Sommet<InfoSommetCarte> >(s, nullptr);

    if (circuit_ == nullptr)
        circuit_ = nouv_element;
    else
    {
        temp = circuit_;
        while (temp->s != nullptr)
            temp = temp->s;
        temp->s = nouv_element;
    }
}


void CircuitGraphe::remove(Sommet<InfoSommetCarte> * s)
{
    if (s == nullptr)
        throw Erreur("Impossible de supprimer un sommet NULL");

    bool trouve = PElement<Sommet<InfoSommetCarte> >::retire(s, circuit_);

    if (trouve == false)
        throw Erreur("Sommet absent de la liste");
}

CircuitGraphe::operator std::string() const
{
    std::ostringstream stream;
    stream << "(";
    PElement<Sommet<InfoSommetCarte> > * temp = circuit_;

    if (temp != nullptr)
    {
        while (temp->s != nullptr)
        {
            stream << temp->v->v.nom << " -> ";
            temp = temp->s;
        }
        stream << temp->v->v.nom;
    }

    stream << ")";
    return stream.str();
}


CircuitGraphe CircuitGraphe::changementAleatoire() const
{
    CircuitGraphe nouv_cg = CircuitGraphe(graphe_);

    // selection des 2 sommets aleatoires non consecutifs -----------------------------------
    Sommet<InfoSommetCarte> * s1 = sommetAleatoire();
    Sommet<InfoSommetCarte> * s2 = sommetAleatoire();
    // si s2 suit, ou est, le sommet s1, on relance l'aleatoire
    // si s1 suit le sommet le s2, idem
    while(s2 == s1 || s2 == sommetSuivant(s1) || s1 == sommetSuivant(s2))
        s2 = sommetAleatoire();

    //---------------------------------------------------------------------------------------

    // on construit un tableau a partir de la liste -----------------------------------------
    // pour faciliter la construction de la nouvelle liste
    int taille = PElement<Sommet<InfoSommetCarte> >::taille(circuit_);
    Sommet<InfoSommetCarte> ** tab_sommets = new Sommet<InfoSommetCarte>*[taille];
    int i{0};
    PElement<Sommet<InfoSommetCarte> > * temp = circuit_;
    Sommet<InfoSommetCarte> * s_preums, * s_deuz;
    bool s_preums_trouve = false;

    // remplissage du tableau
    while (temp != nullptr)
    {
        // on ajoute le sommet au tableau
        tab_sommets[i++] = temp->v;

        // on cherche la position des sommets s1 et s2 l'un par rapport a l'autre dans la liste
        if (s_preums_trouve == false)
        {
            if (temp->v == s1)
            {
                s_preums = s1;
                s_deuz = s2;
                s_preums_trouve = true;
            }
            else
            {
                if (temp->v == s2)
                {
                    s_preums = s2;
                    s_deuz = s1;
                    s_preums_trouve = true;
                }
            }
        }
        temp = temp->s;
    }

    //---------------------------------------------------------------------------------------

    // on ajoute
    CircuitGraphe::nouvListeCircuitGraphe(s_preums, s_deuz, nouv_cg, tab_sommets, taille);

    delete[] tab_sommets;
    return nouv_cg;
}

double CircuitGraphe::coutParcours() const
{
    double res = 0.;
    double inf = std::numeric_limits<double>::infinity();
    PElement<Sommet<InfoSommetCarte> > * temp = circuit_;
    Arete<InfoAreteCarte, InfoSommetCarte> * a;

    if (temp == nullptr)
        return res;

    while (temp->s != nullptr)
    {
        // si il n'y a pas d'arete entre les 2 sommets on renvoie l'infini
        a = graphe_->getAreteParSommets(temp->v, temp->s->v);
        if (a == nullptr)
            return inf;
        res += a->v.cout_;
    }
    // il reste a regarder l'arete entre le dernier sommet et le premier sommet du circuit
    a = graphe_->getAreteParSommets(temp->v, circuit_->v);
    if (a == nullptr)
        return inf;

    return res + a->v.cout_;
}

/*
/////////////////////////////////////////////////////////////////////////////////////////////

    ########  #######  ##    ##  ######  ######## ####  #######  ##    ##  ######
    ##       ##     ## ###   ## ##    ##    ##     ##  ##     ## ###   ## ##    ##
    ##       ##     ## ####  ## ##          ##     ##  ##     ## ####  ## ##
    ######   ##     ## ## ## ## ##          ##     ##  ##     ## ## ## ##  ######
    ##       ##     ## ##  #### ##          ##     ##  ##     ## ##  ####       ##
    ##       ##     ## ##   ### ##    ##    ##     ##  ##     ## ##   ### ##    ##
    ##        #######  ##    ##  ######     ##    ####  #######  ##    ##  ######

/////////////////////////////////////////////////////////////////////////////////////////////
*/

std::ostream & operator<< (std::ostream & os, const CircuitGraphe & op)
{
    return os << std::string(op);
}

CircuitGraphe changementAleatoire(const CircuitGraphe & c)
{
    return c.changementAleatoire();
}

double coutParcours(const CircuitGraphe & c)
{
    return c.coutParcours();
}
